# proyecto
Días 1-14: Búsqueda del Vehículo Base
Las primeras dos semanas las dedicamos a buscar un carrito de control remoto que sirviera como base para nuestro proyecto. Fue un proceso exhaustivo, ya que queríamos asegurarnos de encontrar un modelo adecuado.
Mayo a Julio: Fase de Prototipos
Durante estos meses, trabajamos en varios prototipos. Experimentamos con diferentes configuraciones y componentes, incluyendo uno construido con piezas de Lego. Sin embargo, enfrentamos varios desafíos técnicos, incluyendo problemas con la estructura y el peso de los prototipos.
17 de Junio: Encontrando el Carro Perfecto
Nuestro tutor finalmente nos ayudó a encontrar un carro perfecto el 17 de junio. Este vehículo cumplía con todos los requisitos que necesitábamos para el proyecto, lo que nos permitió avanzar de manera significativa.
Fase de Programación y Desafíos con Servos
Después de encontrar el carro adecuado, comenzamos a programar el sistema. Sin embargo, enfrentamos problemas con los servos, quemando dos de ellos durante las pruebas iniciales. El primer código que escribimos para controlar el servo resultó en la quema del primer servo. Decidimos no usar el segundo servo en ese momento.
27 de Junio: Implementación y Programación
A partir del 27 de junio, comenzamos a integrar todos los componentes y a programar el primer servo nuevamente. Utilizamos pistas caseras para probar y ajustar el sistema. Este proceso nos permitió asegurarnos de que todo funcionara correctamente.
Imagen del Vehículo Actual


CODIGO
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
Servo servoMotor;

// Pines de los sensores ultrasónicos
const int TrigerFrente = 2;
const int EchoFrente = 3;
const int TrigerIzquierda = 4;
const int EchoIzquierda = 5;
const int TrigerDerecha = 6;
const int EchoDerecha = 7;
const int TrigerAtras = 8;
const int EchoAtras = 9;

// Pines del driver del motor
const int motorPin1 = 9;
const int motorPin2 = 10;
const int motorVelocidad = 11;

// Velocidad Del Motor
const int velocidadNormal = 220; // Velocidad Para Todo el Programa 

// Variables para almacenar distancias
long distanciaFrente, distanciaIzquierda, distanciaDerecha, distanciaAtras;

// Tiempo para la actualización de sensores y pantalla
unsigned long tiempoImprimir = 0;
const unsigned long intervaloActualizacion = 50; //Tiempo en que estara actualizando

// Distancias mínimas permitidas para Acomodar
const int distanciaMinimaIzquierda = 17;   // Distancia mínima permitida a la izquierda
const int distanciaMinimaDerecha = 17;     // Distancia mínima permitida a la derecha

// Variable para controlar el tiempo después de evadir obstáculos
unsigned long esperaLuegoEvasion = 0;
const unsigned long intervaloEsperarDespuesEvasion = 800; // Esperar 500 ms después de evadir obstáculos

void setup() {
  lcd.begin(16, 2);
  lcd.backlight();

  // Configuración de los pines de los sensores
  pinMode(TrigerFrente, OUTPUT);
  pinMode(EchoFrente, INPUT);
  pinMode(TrigerIzquierda, OUTPUT);
  pinMode(EchoIzquierda, INPUT);
  pinMode(TrigerDerecha, OUTPUT);
  pinMode(EchoDerecha, INPUT);
  pinMode(TrigerAtras, OUTPUT);
  pinMode(EchoAtras, INPUT);

  // Configuración de los pines del motor
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorVelocidad, OUTPUT);

  // Configuración del servo motor
  servoMotor.attach(12); // Pin del servo motor

  // Encender el motor al inicio
  MovimientoVehiculo(1); 
}

// Función para medir distancia
long MedirDistancia(int trigerPin, int echoPin) {
  digitalWrite(trigerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigerPin, LOW);

  long duracion = pulseIn(echoPin, HIGH, 20000); // Timeout de 20 ms
  if (duracion == 0) return 500; // Si no hay respuesta, asumir distancia máxima (200 cm)
  
  long distancia = duracion * 0.034 / 2;
  return distancia;
}

// Función para controlar el servo
void controlServo(int angulo) {
  servoMotor.write(angulo);
}

// Función para mover el vehículo
void MovimientoVehiculo(int direccion) {
  analogWrite(motorVelocidad, velocidadNormal); // Establecer la velocidad 
  if (direccion == 1) { // Adelante
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else if (direccion == -1) { // Atrás
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else { // Detener
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
  }
}

// Función para actualizar la pantalla LCD
void actualizarLCD() {
  lcd.setCursor(0, 0);
  lcd.print("F:");
  lcd.print(distanciaFrente);
  lcd.print("cm B:");
  lcd.print(distanciaAtras);
  lcd.print("cm    ");  

  lcd.setCursor(0, 1);
  lcd.print("L:");
  lcd.print(distanciaIzquierda);
  lcd.print("cm R:");
  lcd.print(distanciaDerecha);
  lcd.print("cm    ");  
}

// Función para actualizar las distancias
void actualizarDistancias() {
  distanciaFrente = MedirDistancia(TrigerFrente, EchoFrente);
  distanciaIzquierda = MedirDistancia(TrigerIzquierda, EchoIzquierda);
  distanciaDerecha = MedirDistancia(TrigerDerecha, EchoDerecha);
  distanciaAtras = MedirDistancia(TrigerAtras, EchoAtras);
}

// Función para evadir 
void Evadir() {
  // Si hay un objeto(pared)al lado mas grande se dirigira 
  if (distanciaFrente < 76) {
    MovimientoVehiculo(1); // Tener el motor encendido
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio < 950) { // evadir por 950 minisegundos
      if (distanciaIzquierda < distanciaDerecha) { // Si izquierda es mas grande se ajusta el serva para que se mueva a la izquierda
        controlServo(117);
      } else { // SI no se dirigira a la derecha
        controlServo(50);
      }
      delay(10); // para que tenga el sistema en cargar
      actualizarDistancias(); // Actualizar distancias durante la evasión
    }

    controlServo(93); // Centro
    esperaLuegoEvasion = millis(); // Registrar el tiempo de la última evasión
  }
}

// Función para acomodar el vehículo después de la evasión
void acomodar() {
  // Verificar si ha pasado suficiente tiempo desde la última evasión
  if (millis() - esperaLuegoEvasion < intervaloEsperarDespuesEvasion) {
    return; // Si no ha pasado suficiente tiempo, salir de la función
  }

  // Ajustar la posición Para que este lo mas centrado posible 
  if (distanciaIzquierda < distanciaMinimaIzquierda) {
    controlServo(113); // Girar hacia la derecha
    delay(450); 
    controlServo(70); 
    delay(350); 
    controlServo(93); 
    delay(350); // Esto lo que hace es girar y regresar al centro para que el coche no pierda potencia ademas que se mantenaga en un angulo el cual avance
  } else if (distanciaDerecha < distanciaMinimaDerecha) {
    controlServo(62); 
    delay(450); 
    controlServo(108); 
    delay(350); 
    controlServo(93); // Regresar al centro
    delay(350); 
  }
}

void loop() {
  unsigned long tiempoActual = millis();
  if (tiempoActual - tiempoImprimir >= intervaloActualizacion) {
    actualizarDistancias(); // Actualizar las distancias
    actualizarLCD(); // Actualizar la pantalla LCD
    tiempoImprimir = tiempoActual; // Actualizar el tiempo de la última actualización
  }

  Evadir(); // Evasión 
  acomodar(); // Acomodar el vehículo después de evadir obstáculos
  delay(50); // Para no sobre calentar el sistema 
}
PRUEBA DE ARRANQUE 
CODIGO
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
Servo servoMotor;

// Configuración de los sensores ultrasónicos
const int TriggerFrente = 2;
const int EchoFrente = 3;
const int TriggerIzquierda = 4;
const int EchoIzquierda = 5;
const int TriggerDerecha = 6;
const int EchoDerecha = 7;

// Pines del driver del motor
const int motorPin1 = 9;
const int motorPin2 = 10;
const int motorVelocidad = 11;

// Pines para los botones
const int pinIzqGiro = 8; // Botón para activar el sistema

// Velocidad del vehículo
const int velocidadNormal =166; // Velocidad normal para todo el vehículo

// Variables para almacenar distancias
long distanciaFrente, distanciaIzquierda, distanciaDerecha, distanciaAtras;

// Intervalos para la actualización de sensores y pantalla
unsigned long ultimoTiempoActualizacion = 0;
const unsigned long intervaloActualizacion = 80; // Reducido a 50 ms para más frecuencia

// Distancias mínimas permitidas para el centrado
const int distanciaMinimaIzquierda = 31;   // Distancia mínima permitida a la izquierda
const int distanciaMinimaDerecha = 31;     // Distancia mínima permitida a la derecha

// Variable para controlar el tiempo después de evadir obstáculos
unsigned long tiempoUltimaEvasion = 0;
const unsigned long intervaloEsperarDespuesEvasion = 100; // Esperar 500 ms después de evadir obstáculos

bool sistemaActivado = false; // Estado del sistema
bool inicioEjecutado = false; // Variable para controlar si inicio() ya se ejecutó una vez
void setup() {
  lcd.begin(16, 2);
  lcd.backlight();

  // Configuración de los pines de los sensores
  pinMode(TriggerFrente, OUTPUT);
  pinMode(EchoFrente, INPUT);
  pinMode(TriggerIzquierda, OUTPUT);
  pinMode(EchoIzquierda, INPUT);
  pinMode(TriggerDerecha, OUTPUT);
  pinMode(EchoDerecha, INPUT);

  // Configuración de los pines del motor
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorVelocidad, OUTPUT);

  // Configuración del servo motor
  servoMotor.attach(12); // Pin del servo motor
  controlServo(142); // Centrar el servo motor al inicio

  // Configuración del botón para activar el sistema
  pinMode(pinIzqGiro, INPUT_PULLUP); // Pin 8 como entrada con resistencia pull-up

  // No encender el motor al inicio
  moverVehiculo(0); // Detener el vehículo al inicio
}

// Función para medir distancia
long getDistancia(int triggerPin, int echoPin) {
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);

  long duracion = pulseIn(echoPin, HIGH, 20000); // Timeout de 20 ms
  if (duracion == 0) return 500; // Si no hay respuesta, asumir distancia máxima (200 cm)
  
  long distancia = duracion * 0.034 / 2;
  return distancia;
}

// Función para controlar el servo
void controlServo(int angulo) {
  servoMotor.write(angulo);
}

// Función para mover el vehículo
void moverVehiculo(int direccion) {
  analogWrite(motorVelocidad, velocidadNormal); // Establecer la velocidad normal
  if (direccion == 1) { // Adelante
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else if (direccion == -1) { // Atrás
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else { // Detener
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
  }
}

// Función para actualizar la pantalla LCD
void actualizarLCD() {
  lcd.setCursor(0, 0);
  lcd.print("F:");
  lcd.print(distanciaFrente);
  lcd.print("cm B:");
  lcd.print(distanciaAtras);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales

  lcd.setCursor(0, 1);
  lcd.print("L:");
  lcd.print(distanciaIzquierda);
  lcd.print("cm R:");
  lcd.print(distanciaDerecha);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales
}

// Función para actualizar las distancias
void actualizarDistancias() {
  distanciaFrente = getDistancia(TriggerFrente, EchoFrente);
  distanciaIzquierda = getDistancia(TriggerIzquierda, EchoIzquierda);
  distanciaDerecha = getDistancia(TriggerDerecha, EchoDerecha);
}

// Función para evadir obstáculos hacia la izquierda
void evadirIzq() {
  if (distanciaFrente < 84) {
    moverVehiculo(1); // Avanzar durante la evasión
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio < 1250) { // Evasión de obstáculos por 1.2 segundos
      controlServo(109); // Dirección hacia la izquierda
      delay(10); // Reducido para lecturas rápidas de los sensores
      actualizarDistancias(); // Actualizar distancias durante la evasión
    }
    controlServo(141); // Volver al centro al finalizar la evasión
    tiempoUltimaEvasion = millis(); // Registrar el tiempo de la última evasión
  }
}

// Función para acomodar el vehículo después de la evasión
void acomodar() {
  // Verificar si ha pasado suficiente tiempo desde la última evasión
  if (millis() - tiempoUltimaEvasion < intervaloEsperarDespuesEvasion) {
    return; // Si no ha pasado suficiente tiempo, salir de la función
  }
  if (distanciaFrente < 105){
    return;
  }
  // Ajustar la posición del vehículo para mantenerlo en el centro del espacio
  if (distanciaIzquierda < distanciaMinimaIzquierda) {
    controlServo(156); // Girar hacia la derecha
    delay(300); // Gi8rar por 600 ms en dirección contraria
    controlServo(134); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  } else if (distanciaDerecha < distanciaMinimaDerecha) {
    controlServo(125); // Girar hacia la izquierda
    delay(300); // Girar por 600 ms en dirección contraria
    controlServo(150); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  }
}

// Función para verificar las condiciones de inicio
void inicio() {
  long distanciaFrontal = getDistancia(TriggerFrente, EchoFrente);
  long distanciaDer = getDistancia(TriggerDerecha, EchoDerecha);
  long distanciaIz = getDistancia(TriggerIzquierda, EchoIzquierda);

  // Opción 1: frontal entre 94 y 122 cm, derecha entre 9 y 28 cm
  if (distanciaFrontal >= 94 && distanciaFrontal <= 122 && distanciaDer >= 9 && distanciaDer <= 28) {
    // Mover hacia atrás por 2550 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2550) { 
      if (millis() - tiempoInicio <= 300) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1300) {
        controlServo(116); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2150) {
        controlServo(158); 
        delay(250); 
      } else {
        controlServo(140); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }

    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(116); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(141); // Volver al centro con 300 ms de delay al final
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }

  // Opción 2: frontal entre 146 y 173 cm, derecha entre 6 y 28 cm
  else if (distanciaFrontal >= 147 && distanciaFrontal <= 172 && distanciaDer >= 7 && distanciaDer <= 25) {
    // Mover hacia atrás por 650 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms

    // Detener el vehículo
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    // Avanzar por 500 milisegundos con el servo en el centro
    moverVehiculo(1); // Avanzar
    controlServo(141); // Mantener el servo en el centro
    delay(500); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(116); // Girar el servo a 67 grados
    delay(950); // Esperar 650 milisegundos

    // Girar el servo a 108 grados por 750 milisegundos
    controlServo(158); // Girar el servo a 108 grados
    delay(500); // Esperar 750 milisegundos

    // Girar el servo al centro (93 grados) por 300 milisegundos
    controlServo(141); // Volver al centro
    delay(300); // Esperar 300 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 3
  else if(distanciaFrontal >= 97 && distanciaFrontal <= 123 && distanciaIz >= 7 && distanciaIz <= 26) {
   moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2850) { 
      if (millis() - tiempoInicio <= 600) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1400) {
        controlServo(164); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2250) {
        controlServo(126); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }
    
    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(162); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(138);
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 4
  else if (distanciaFrontal >= 147 && distanciaFrontal <= 171 && distanciaIz >= 7 && distanciaIz <= 26) {
    controlServo(158);
    moverVehiculo(-1); // Mover hacia atrás
    delay(2500); // Esperar 650 ms
    controlServo(141);
    delay(1000);
  
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    controlServo(158);
    moverVehiculo(1); // Avanzar
    delay(2800);

    controlServo(130); // Mantener el servo en el centro
    delay(450); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(141); // Girar el servo a 67 grados
    delay(500); // Esperar 650 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
}

void loop() {
 unsigned long tiempoActual = millis();

  // Actualizar distancias y pantalla LCD
  if (tiempoActual - ultimoTiempoActualizacion >= intervaloActualizacion) {
    actualizarDistancias(); // Actualizar las distancias
    actualizarLCD(); // Actualizar la pantalla LCD
    ultimoTiempoActualizacion = tiempoActual; // Actualizar el tiempo de la última actualización
  }

  // Leer estado del botón IzqGiro para activar el sistema
  if (!sistemaActivado && digitalRead(pinIzqGiro) == LOW) {
    sistemaActivado = true;
    if (!inicioEjecutado) {
      inicio();
      inicioEjecutado = true; // Marcar que inicio() ya se ejecutó una vez
    }
    moverVehiculo(1); // Encender el vehículo al activar el sistema
    evadirIzq(); // Iniciar evasión hacia la izquierda al activar el sistema
    acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
  }

  // Ejecutar lógica del sistema si está activado
  if (sistemaActivado) {
    // Lógica del sistema aquí
    evadirIzq(); // Evasión de obstáculos continua hacia la izquierda (bloqueado después del primer uso)
    acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
  }

  // Mantener un pequeño delay para mejorar la frecuencia de iteración
  delay(50);
} 
}
CODIGO DERECHA 
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
Servo servoMotor;

// Configuración de los sensores ultrasónicos
const int TriggerFrente = 2;
const int EchoFrente = 3;
const int TriggerIzquierda = 4;
const int EchoIzquierda = 5;
const int TriggerDerecha = 6;
const int EchoDerecha = 7;

// Pines del driver del motor
const int motorPin1 = 9;
const int motorPin2 = 10;
const int motorVelocidad = 11;

// Pines para los botones
const int pinDerGiro = 13; // Botón para activar el sistema hacia la derecha

// Velocidad del vehículo
const int velocidadNormal = 166; // Velocidad normal para todo el vehículo

// Variables para almacenar distancias
long distanciaFrente, distanciaIzquierda, distanciaDerecha, distanciaAtras;

// Intervalos para la actualización de sensores y pantalla
unsigned long ultimoTiempoActualizacion = 0;
const unsigned long intervaloActualizacion = 100; // Reducido a 50 ms para más frecuencia

// Distancias mínimas permitidas para el centrado
const int distanciaMinimaIzquierda = 31;   // Distancia mínima permitida a la izquierda
const int distanciaMinimaDerecha = 31;     // Distancia mínima permitida a la derecha

// Variable para controlar el tiempo después de evadir obstáculos
unsigned long tiempoUltimaEvasion = 0;
const unsigned long intervaloEsperarDespuesEvasion = 100; // Esperar 500 ms después de evadir obstáculos

bool sistemaActivado = false; // Estado del sistema
bool inicioEjecutado = false; // Estado de evasión derecha activo

void setup() {
  lcd.begin(16, 2);
  lcd.backlight();

  // Configuración de los pines de los sensores
  pinMode(TriggerFrente, OUTPUT);
  pinMode(EchoFrente, INPUT);
  pinMode(TriggerIzquierda, OUTPUT);
  pinMode(EchoIzquierda, INPUT);
  pinMode(TriggerDerecha, OUTPUT);
  pinMode(EchoDerecha, INPUT);

  // Configuración de los pines del motor
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorVelocidad, OUTPUT);

  // Configuración del servo motor
  servoMotor.attach(12); // Pin del servo motor
   controlServo(141); 
  // Configuración del botón para activar el sistema hacia la derecha
  pinMode(pinDerGiro, INPUT_PULLUP); // Pin 13 como entrada con resistencia pull-up

  // No encender el motor al inicio
  moverVehiculo(0); // Detener el vehículo al inicio
}

// Función para medir distancia
long getDistancia(int triggerPin, int echoPin) {
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);

  long duracion = pulseIn(echoPin, HIGH, 20000); // Timeout de 20 ms
  if (duracion == 0) return 500; // Si no hay respuesta, asumir distancia máxima (200 cm)
  
  long distancia = duracion * 0.034 / 2;
  return distancia;
}

// Función para controlar el servo
void controlServo(int angulo) {
  servoMotor.write(angulo);
}

// Función para mover el vehículo
void moverVehiculo(int direccion) {
  analogWrite(motorVelocidad, velocidadNormal); // Establecer la velocidad normal
  if (direccion == 1) { // Adelante
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else if (direccion == -1) { // Atrás
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else { // Detener
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
  }
}

// Función para actualizar la pantalla LCD
void actualizarLCD() {
  lcd.setCursor(0, 0);
  lcd.print("F:");
  lcd.print(distanciaFrente);
  lcd.print("cm B:");
  lcd.print(distanciaAtras);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales

  lcd.setCursor(0, 1);
  lcd.print("L:");
  lcd.print(distanciaIzquierda);
  lcd.print("cm R:");
  lcd.print(distanciaDerecha);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales
}

// Función para actualizar las distancias
void actualizarDistancias() {
  distanciaFrente = getDistancia(TriggerFrente, EchoFrente);
  distanciaIzquierda = getDistancia(TriggerIzquierda, EchoIzquierda);
  distanciaDerecha = getDistancia(TriggerDerecha, EchoDerecha);
}

// Función para evadir obstáculos hacia la derecha
void evadirDer() {
  if (distanciaFrente < 84) {
    moverVehiculo(1); // Avanzar durante la evasión
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio < 1250) { // Evasión de obstáculos por 1.2 segundos
      controlServo(170); // Dirección hacia la derecha
      delay(10); // Reducido para lecturas rápidas de los sensores
      actualizarDistancias(); // Actualizar distancias durante la evasión
    }
    controlServo(141); // Volver al centro al finalizar la evasión
    tiempoUltimaEvasion = millis(); // Registrar el tiempo de la última evasión
  }
}

// Función para acomodar el vehículo después de la evasión
void acomodar() {
  // Verificar si ha pasado suficiente tiempo desde la última evasión
  if (millis() - tiempoUltimaEvasion < intervaloEsperarDespuesEvasion) {
    return; // Si no ha pasado suficiente tiempo, salir de la función
  }
  if (distanciaFrente < 105){
    return;
  }
  // Ajustar la posición del vehículo para mantenerlo en el centro del espacio
  if (distanciaIzquierda < distanciaMinimaIzquierda) {
    controlServo(156); // Girar hacia la derecha
    delay(300); // Gi8rar por 600 ms en dirección contraria
    controlServo(133); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  } else if (distanciaDerecha < distanciaMinimaDerecha) {
    controlServo(125); // Girar hacia la izquierda
    delay(300); // Girar por 600 ms en dirección contraria
    controlServo(149); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  }
}

// Función para verificar las condiciones de inicio
void inicio() {
  long distanciaFrontal = getDistancia(TriggerFrente, EchoFrente);
  long distanciaDer = getDistancia(TriggerDerecha, EchoDerecha);
  long distanciaIz = getDistancia(TriggerIzquierda, EchoIzquierda);

  // Opción 1: frontal entre 94 y 122 cm, derecha entre 9 y 28 cm
  if (distanciaFrontal >= 97 && distanciaFrontal <= 122 && distanciaIz >= 6 && distanciaIz <= 26) {
    // Mover hacia atrás por 2550 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2550) { 
      if (millis() - tiempoInicio <= 300) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1300) {
        controlServo(166); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2150) {
        controlServo(124); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }

    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(166); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(141); // Volver al centro con 300 ms de delay al final
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }

  // Opción 2: frontal entre 146 y 173 cm, derecha entre 6 y 28 cm
  else if (distanciaFrontal >= 145 && distanciaFrontal <= 172 && distanciaIz >= 7 && distanciaIz <= 26) {
    // Mover hacia atrás por 650 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms

    // Detener el vehículo
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    // Avanzar por 500 milisegundos con el servo en el centro
    moverVehiculo(1); // Avanzar
    controlServo(141); // Mantener el servo en el centro
    delay(500); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(166); // Girar el servo a 67 grados
    delay(950); // Esperar 650 milisegundos

    // Girar el servo a 108 grados por 750 milisegundos
    controlServo(124); // Girar el servo a 108 grados
    delay(500); // Esperar 750 milisegundos

    // Girar el servo al centro (93 grados) por 300 milisegundos
    controlServo(141); // Volver al centro
    delay(300); // Esperar 300 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 3
  else if(distanciaFrontal >= 97 && distanciaFrontal <= 123 && distanciaDer >= 7 && distanciaDer <= 27) {
   moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2850) { 
      if (millis() - tiempoInicio <= 600) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1400) {
        controlServo(118); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2250) {
        controlServo(156); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }
    
    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(139); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(143);
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 4
  else if (distanciaFrontal >= 146 && distanciaFrontal <= 171 && distanciaDer >= 7 && distanciaDer <= 27) {
    controlServo(128);
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms
    controlServo(141);
    delay(700);
  
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    controlServo(124);
    moverVehiculo(1); // Avanzar
    delay(2800);

    controlServo(152); // Mantener el servo en el centro
    delay(450); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(141); // Girar el servo a 67 grados
    delay(500); // Esperar 650 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
}

void loop() {
  unsigned long tiempoActual = millis();

  // Actualizar distancias y pantalla LCD
  if (tiempoActual - ultimoTiempoActualizacion >= intervaloActualizacion) {
    actualizarDistancias(); // Actualizar las distancias
    actualizarLCD(); // Actualizar la pantalla LCD
    ultimoTiempoActualizacion = tiempoActual; // Actualizar el tiempo de la última actualización
  }

  // Leer estado del botón IzqGiro para activar el sistema
  if (!sistemaActivado && digitalRead(pinDerGiro) == LOW) {
    sistemaActivado = true;
    if (!inicioEjecutado) {
      inicio();
      inicioEjecutado = true; // Marcar que inicio() ya se ejecutó una vez
    }
    moverVehiculo(1); // Encender el vehículo al activar el sistema
    evadirDer(); // Iniciar evasión hacia la izquierda al activar el sistema
    acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
  }

  // Ejecutar lógica del sistema si está activado
  if (sistemaActivado) {
    // Lógica del sistema aquí
    evadirDer(); // Evasión de obstáculos continua hacia la izquierda (bloqueado después del primer uso)
    acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
  }

  // Mantener un pequeño delay para mejorar la frecuencia de iteración
  delay(50);
}

El primer código fue esencial para avanzar, pero tuvimos dificultades con los sensores.
Entonces decidimos cambiarlo para que el dispositivo se moviera a la derecha e izquierda mediante botones. 
Después de aproximadamente 20 días, logramos superar estos problemas y unimos los componentes del proyecto, obteniendo un sistema funcional.
CODIGO COMPLETO 
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
Servo servoMotor;

// Configuración de los sensores ultrasónicos
const int TriggerFrente = 2;
const int EchoFrente = 3;
const int TriggerIzquierda = 4;
const int EchoIzquierda = 5;
const int TriggerDerecha = 6;
const int EchoDerecha = 7;

// Pines del driver del motor
const int motorPin1 = 9;
const int motorPin2 = 10;
const int motorVelocidad = 11;

// Pines para los botones
const int pinIzqGiro = 8; // Botón para activar el sistema
const int pinDerGiro = 13; // Botón para activar el sistema hacia la derecha

// Velocidad del vehículo
const int velocidadNormal =166; // Velocidad normal para todo el vehículo

// Variables para almacenar distancias
long distanciaFrente, distanciaIzquierda, distanciaDerecha, distanciaAtras;

// Intervalos para la actualización de sensores y pantalla
unsigned long ultimoTiempoActualizacion = 0;
const unsigned long intervaloActualizacion = 80; // Reducido a 50 ms para más frecuencia

// Distancias mínimas permitidas para el centrado
const int distanciaMinimaIzquierda = 31;   // Distancia mínima permitida a la izquierda
const int distanciaMinimaDerecha = 31;     // Distancia mínima permitida a la derecha

// Variable para controlar el tiempo después de evadir obstáculos
unsigned long tiempoUltimaEvasion = 0;
const unsigned long intervaloEsperarDespuesEvasion = 100; // Esperar 500 ms después de evadir obstáculos

bool sistemaActivadoI = false; // Estado del sistema
bool inicioEjecutadoI = false;

bool sistemaActivadoD = false; 
bool inicioEjecutadoD = false; 

int contadorEvasiones = 0;

void setup() {
  lcd.begin(16, 2);
  lcd.backlight();

  // Configuración de los pines de los sensores
  pinMode(TriggerFrente, OUTPUT);
  pinMode(EchoFrente, INPUT);
  pinMode(TriggerIzquierda, OUTPUT);
  pinMode(EchoIzquierda, INPUT);
  pinMode(TriggerDerecha, OUTPUT);
  pinMode(EchoDerecha, INPUT);

  // Configuración de los pines del motor
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorVelocidad, OUTPUT);

  // Configuración del servo motor
  servoMotor.attach(12); // Pin del servo motor
  controlServo(142); // Centrar el servo motor al inicio

  // Configuración del botón para activar el sistema
  pinMode(pinIzqGiro, INPUT_PULLUP); // Pin 8 como entrada con resistencia pull-up
  pinMode(pinDerGiro, INPUT_PULLUP);

  // No encender el motor al inicio
  moverVehiculo(0); // Detener el vehículo al inicio
}
// Función para medir distancia
long getDistancia(int triggerPin, int echoPin) {
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);

  long duracion = pulseIn(echoPin, HIGH, 20000); // Timeout de 20 ms
  if (duracion == 0) return 500; // Si no hay respuesta, asumir distancia máxima (200 cm)
  
  long distancia = duracion * 0.034 / 2;
  return distancia;
}

// Función para controlar el servo
void controlServo(int angulo) {
  servoMotor.write(angulo);
}

// Función para mover el vehículo
void moverVehiculo(int direccion) {
  analogWrite(motorVelocidad, velocidadNormal); // Establecer la velocidad normal
  if (direccion == 1) { // Adelante
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else if (direccion == -1) { // Atrás
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else { // Detener
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
  }
}

// Función para actualizar la pantalla LCD
void actualizarLCD() {
  lcd.setCursor(0, 0);
  lcd.print("F:");
  lcd.print(distanciaFrente);
  lcd.print("cm B:");
  lcd.print(distanciaAtras);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales

  lcd.setCursor(0, 1);
  lcd.print("L:");
  lcd.print(distanciaIzquierda);
  lcd.print("cm R:");
  lcd.print(distanciaDerecha);
  lcd.print("cm    ");  // Añadir espacios para borrar caracteres adicionales
}
// Función para actualizar las distancias
void actualizarDistancias() {
  distanciaFrente = getDistancia(TriggerFrente, EchoFrente);
  distanciaIzquierda = getDistancia(TriggerIzquierda, EchoIzquierda);
  distanciaDerecha = getDistancia(TriggerDerecha, EchoDerecha);
}

void evadirDer() {
  if (distanciaFrente < 84) {
    moverVehiculo(1); // Avanzar durante la evasión
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio < 1250) { // Evasión de obstáculos por 1.2 segundos
      controlServo(170); // Dirección hacia la derecha
      delay(10); // Reducido para lecturas rápidas de los sensores
      actualizarDistancias(); // Actualizar distancias durante la evasión
    }
    controlServo(141); // Volver al centro al finalizar la evasión
    tiempoUltimaEvasion = millis(); // Registrar el tiempo de la última evasión

    // Incrementar el contador de evasiones
    contadorEvasiones++;
    // Detener el vehículo si se alcanzan 12 evasiones
    if (contadorEvasiones >= 12) {
      moverVehiculo(0); // Detener el vehículo
    }
  }
}

// Función para evadir obstáculos hacia la izquierda
void evadirIzq() {
  if (distanciaFrente < 84) {
    moverVehiculo(1); // Avanzar durante la evasión
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio < 1250) { // Evasión de obstáculos por 1.2 segundos
      controlServo(109); // Dirección hacia la izquierda
      delay(10); // Reducido para lecturas rápidas de los sensores
      actualizarDistancias(); // Actualizar distancias durante la evasión
    }
    controlServo(141); // Volver al centro al finalizar la evasión
    tiempoUltimaEvasion = millis(); // Registrar el tiempo de la última evasión

    // Incrementar el contador de evasiones
    contadorEvasiones++;
    // Detener el vehículo si se alcanzan 12 evasiones
    if (contadorEvasiones >= 12) {
      moverVehiculo(0); // Detener el vehículo
    }
  }
}
// Función para acomodar el vehículo después de la evasión
void acomodar() {
  // Verificar si ha pasado suficiente tiempo desde la última evasión
  if (millis() - tiempoUltimaEvasion < intervaloEsperarDespuesEvasion) {
    return; // Si no ha pasado suficiente tiempo, salir de la función
  }
  if (distanciaFrente < 105){
    return;
  }
  // Ajustar la posición del vehículo para mantenerlo en el centro del espacio
  if (distanciaIzquierda < distanciaMinimaIzquierda) {
    controlServo(156); // Girar hacia la derecha
    delay(300); // Gi8rar por 600 ms en dirección contraria
    controlServo(133); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  } else if (distanciaDerecha < distanciaMinimaDerecha) {
    controlServo(125); // Girar hacia la izquierda
    delay(300); // Girar por 600 ms en dirección contraria
    controlServo(149); // Girar un poco hacia la dirección de la pared
    delay(200); // Esperar 350 ms
    controlServo(141); // Regresar al centro
    delay(50); // Esperar para permitir que el servo regrese al centro
  }
}
// Función para verificar las condiciones de inicio
void inicioDer() {
  long distanciaFrontal = getDistancia(TriggerFrente, EchoFrente);
  long distanciaDer = getDistancia(TriggerDerecha, EchoDerecha);
  long distanciaIz = getDistancia(TriggerIzquierda, EchoIzquierda);

  // Opción 1: frontal entre 94 y 122 cm, derecha entre 9 y 28 cm
  if (distanciaFrontal >= 97 && distanciaFrontal <= 122 && distanciaIz >= 6 && distanciaIz <= 26) {
    // Mover hacia atrás por 2550 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2550) { 
      if (millis() - tiempoInicio <= 300) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1300) {
        controlServo(166); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2150) {
        controlServo(124); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }

    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(166); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(141); // Volver al centro con 300 ms de delay al final
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }

  // Opción 2: frontal entre 146 y 173 cm, derecha entre 6 y 28 cm
  else if (distanciaFrontal >= 145 && distanciaFrontal <= 172 && distanciaIz >= 7 && distanciaIz <= 26) {
    // Mover hacia atrás por 650 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms

    // Detener el vehículo
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    // Avanzar por 500 milisegundos con el servo en el centro
    moverVehiculo(1); // Avanzar
    controlServo(141); // Mantener el servo en el centro
    delay(500); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(166); // Girar el servo a 67 grados
    delay(950); // Esperar 650 milisegundos

    // Girar el servo a 108 grados por 750 milisegundos
    controlServo(124); // Girar el servo a 108 grados
    delay(500); // Esperar 750 milisegundos

    // Girar el servo al centro (93 grados) por 300 milisegundos
    controlServo(141); // Volver al centro
    delay(300); // Esperar 300 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 3
  else if(distanciaFrontal >= 97 && distanciaFrontal <= 123 && distanciaDer >= 7 && distanciaDer <= 27) {
   moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2850) { 
      if (millis() - tiempoInicio <= 600) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1400) {
        controlServo(118); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2250) {
        controlServo(156); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }
    
    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(139); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(143);
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 4
  else if (distanciaFrontal >= 146 && distanciaFrontal <= 171 && distanciaDer >= 7 && distanciaDer <= 27) {
    controlServo(128);
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms
    controlServo(141);
    delay(700);
  
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    controlServo(124);
    moverVehiculo(1); // Avanzar
    delay(2800);

    controlServo(152); // Mantener el servo en el centro
    delay(450); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(141); // Girar el servo a 67 grados
    delay(500); // Esperar 650 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
}

// Función para verificar las condiciones de inicio
void inicioIzq() {
  long distanciaFrontal = getDistancia(TriggerFrente, EchoFrente);
  long distanciaDer = getDistancia(TriggerDerecha, EchoDerecha);
  long distanciaIz = getDistancia(TriggerIzquierda, EchoIzquierda);

  // Opción 1: frontal entre 94 y 122 cm, derecha entre 9 y 28 cm
  if (distanciaFrontal >= 94 && distanciaFrontal <= 122 && distanciaDer >= 9 && distanciaDer <= 28) {
    // Mover hacia atrás por 2550 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2550) { 
      if (millis() - tiempoInicio <= 300) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1300) {
        controlServo(116); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2150) {
        controlServo(158); 
        delay(250); 
      } else {
        controlServo(140); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }

    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(116); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(141); // Volver al centro con 300 ms de delay al final
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }

  // Opción 2: frontal entre 146 y 173 cm, derecha entre 6 y 28 cm
  else if (distanciaFrontal >= 147 && distanciaFrontal <= 172 && distanciaDer >= 7 && distanciaDer <= 25) {
    // Mover hacia atrás por 650 milisegundos
    moverVehiculo(-1); // Mover hacia atrás
    delay(1800); // Esperar 650 ms

    // Detener el vehículo
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    // Avanzar por 500 milisegundos con el servo en el centro
    moverVehiculo(1); // Avanzar
    controlServo(141); // Mantener el servo en el centro
    delay(500); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(116); // Girar el servo a 67 grados
    delay(950); // Esperar 650 milisegundos

    // Girar el servo a 108 grados por 750 milisegundos
    controlServo(158); // Girar el servo a 108 grados
    delay(500); // Esperar 750 milisegundos

    // Girar el servo al centro (93 grados) por 300 milisegundos
    controlServo(141); // Volver al centro
    delay(300); // Esperar 300 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 3
  else if(distanciaFrontal >= 97 && distanciaFrontal <= 123 && distanciaIz >= 7 && distanciaIz <= 26) {
   moverVehiculo(-1); // Mover hacia atrás
    
    unsigned long tiempoInicio = millis();
    while (millis() - tiempoInicio <= 2850) { 
      if (millis() - tiempoInicio <= 600) {
        controlServo(141); 
      } else if (millis() - tiempoInicio <= 1400) {
        controlServo(164); 
        delay(100); 
      } else if (millis() - tiempoInicio <= 2250) {
        controlServo(126); 
        delay(250); 
      } else {
        controlServo(141); // Volver al centro con 300 ms de delay al final
      }
      delay(10); // Pequeño delay para permitir que los movimientos del servo se ejecuten
    }
    
    // Después de los movimientos del servo, avanzar hacia adelante por 650 ms con el servo en 67 grados
    moverVehiculo(1); // Avanzar durante 650 ms
    controlServo(162); // Mantener el servo en 67 grados durante el avance
    delay(900); // Avanzar durante 650 ms
    controlServo(138);
    // Actualizar distancias después del avance
    actualizarDistancias(); // <--- Agregar esta línea para actualizar las distancias

    // Detener el vehículo al finalizar el avance
    moverVehiculo(0); // Detener el vehículo
  }
  //Opcion 4
  else if (distanciaFrontal >= 147 && distanciaFrontal <= 171 && distanciaIz >= 7 && distanciaIz <= 26) {
    controlServo(158);
    moverVehiculo(-1); // Mover hacia atrás
    delay(2500); // Esperar 650 ms
    controlServo(141);
    delay(1000);
  
    moverVehiculo(0); // Detener el vehículo
    delay(150); // Detenerse por 200 milisegundos

    controlServo(158);
    moverVehiculo(1); // Avanzar
    delay(2800);

    controlServo(130); // Mantener el servo en el centro
    delay(450); // Avanzar por 500 milisegundos

    // Girar el servo a 67 grados y avanzar por 650 milisegundos
    controlServo(141); // Girar el servo a 67 grados
    delay(500); // Esperar 650 milisegundos

    // Actualizar las distancias al finalizar
    actualizarDistancias(); // Actualizar las distancias

    // Detener el vehículo al finalizar
    moverVehiculo(0); // Detener el vehículo
  }
}
void loop() {
    unsigned long tiempoActual = millis();

    // Actualizar distancias y pantalla LCD
    if (tiempoActual - ultimoTiempoActualizacion >= intervaloActualizacion) {
        actualizarDistancias(); // Actualizar las distancias
        actualizarLCD(); // Actualizar la pantalla LCD
        ultimoTiempoActualizacion = tiempoActual; // Actualizar el tiempo de la última actualización
    }

    // Leer estado del botón IzqGiro para activar el sistema

    if (!sistemaActivadoI && digitalRead(pinIzqGiro) == LOW) {
        sistemaActivadoI = true;
        if (!inicioEjecutadoI) {
            inicioIzq(); // Ejecutar inicioIzq() al activar el sistema con el botón IzqGiro
            inicioEjecutadoI = true; // Marcar que inicioIzq() ya se ejecutó una vez
        }
        moverVehiculo(1); // Encender el vehículo al activar el sistema
        evadirIzq(); // Iniciar evasión hacia la izquierda
        acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
    }

    // Leer estado del botón DerGiro para activar el sistema
    if (!sistemaActivadoD && digitalRead(pinDerGiro) == LOW) {
        sistemaActivadoD = true;
        if (!inicioEjecutadoD) {
            inicioDer(); // Ejecutar inicioDer() al activar el sistema con el botón DerGiro
            inicioEjecutadoD = true; // Marcar que inicioDer() ya se ejecutó una vez
        }
        moverVehiculo(1); // Encender el vehículo al activar el sistema
        evadirDer(); // Iniciar evasión hacia la derecha
        acomodar(); // Acomodar el vehículo después de evadir obstáculos si es necesario
    }

    // Ejecutar lógica del sistema si está activado
    if (sistemaActivadoI) {
        evadirIzq(); // Evasión hacia la izquierda
        acomodar(); // Acomodar el vehículo después de evadir
    }

    if (sistemaActivadoD) {
        evadirDer(); // Evasión hacia la derecha
        acomodar(); // Acomodar el vehículo después de evadir
    }

    // Aquí puedes agregar cualquier lógica adicional o temporizadores

    // Mantener un pequeño delay para mejorar la frecuencia de iteración
    delay(50);
}




























































































































































































































































































































































































































